/* $Revision: 1.3 $ */
// Automatically generated by MATLAB Project Wizard version 1.0

//
// This is the gateway routine for a MATLAB Math/Graphics Library-based
// C MATLAB MEX File.
//
// Gateway routine for Matlab to run Software Correlator
// by Oleg Krichevsky, Ben-Gurion University, Dec. 2003
// okrichev@bgu.ac.il

#include "mex.h"
#include "Correlator.h"
#include "CountCorrelator.h"
#include "CorrArray.h"
//#include <afxtempl.h>  //support for array template
//#include <afxwin.h>
#define PhDelayCorrelator 1
#define PhCountCorrelator 2

#define ARRAY_MAXSIZE  50

#define DoublingSize 16
#define NumOfCorrelators 24
#define FirstSamplingTime 1


void mexFunction(
	int nlhs,              // Number of left hand side (output) arguments
	mxArray *plhs[],       // Array of left hand side arguments
	int nrhs,              // Number of right hand side (input) arguments
	const mxArray *prhs[]  // Array of right hand side arguments
)
{
	int CorrelatorType = PhDelayCorrelator; //default correlator Photon History
	
	if (nrhs == 0) 
		mexErrMsgTxt("At least one input is required.");
	else if (nrhs == 2)
	{
		// Getting the correlator type
		int checkrows = mxGetM(prhs[1]);
		int checkcols = mxGetN(prhs[1]);
		if (!(checkrows == 1 && checkcols == 1)) 
			mexErrMsgTxt("Second input must be a noncomplex scalar double.");

		CorrelatorType = *(mxGetPr(prhs[1]));
	}
	else if (nrhs > 2)
		mexErrMsgTxt("Too many output arguments.");
	

	int Nentries = 0;

	double* phHist = mxGetPr(prhs[0]);
  
	/* Get the dimensions of the matrix input y. */
	int mrows = mxGetM(prhs[0]);
	int ncols = mxGetN(prhs[0]);


	if (mrows == 1)
		Nentries = ncols;
	else if (ncols == 1)
		Nentries = mrows;
	else 
		mexErrMsgTxt("Input y must be a vector.");

	if (CorrelatorType == PhDelayCorrelator)
	{
		CCorrArray<CCorrelator, NumOfCorrelators> CorrelatorArray(NumOfCorrelators, DoublingSize);
		
		/* Set the output pointer to the output matrix. */
		plhs[0] = mxCreateDoubleMatrix(CorrelatorArray.TotalLength, 3, mxREAL);
  
		/* Create a C pointer to a copy of the output matrix. */
		double* corr = mxGetPr(plhs[0]);


		double* HistEnd = phHist + Nentries;
		for (; phHist < HistEnd; )
			CorrelatorArray.ProcessEntry(*phHist++);
	
		CorrelatorArray.GetAccumulators(corr);

	}
	else if (CorrelatorType == PhCountCorrelator)
	{
		CCorrArray<CCountCorrelator, NumOfCorrelators> CorrelatorArray(NumOfCorrelators, DoublingSize);

		/* Set the output pointer to the output matrix. */
		plhs[0] = mxCreateDoubleMatrix(CorrelatorArray.TotalLength, 3, mxREAL);
  
		/* Create a C pointer to a copy of the output matrix. */
		double* corr = mxGetPr(plhs[0]);


		double* HistEnd = phHist + Nentries;
		for (; phHist < HistEnd; )
			CorrelatorArray.ProcessEntry(*phHist++);
	
		CorrelatorArray.GetAccumulators(corr);

	}
		else 
			mexErrMsgTxt("Nonexistent correlator type.");

  

}


